# -*- coding: utf-8 -*-
"""Day6_Quiz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Tij9HWksd_ZAzzvqix3G_w6IIG0Bhy5

- Build a linear models of degree 2 to estimate $v_l$ <br>
- Use 4 samples of train data for training and  <br>
- Use gradient descent method for finding the weights. <br>
- Update the weights for each sample. <br>
- Do weight updates for 100 epochs. (use train data only) <br>
- Report the values predicted on the 3 samples of test data in the variable Y_pred_test (shape is (3,))

- Hint : Take inputs in units of metres (0.6, 0.5, 0.3, 0.2)

### Train Data
| Sonar S | $v_l$   |$v_r$|
|---------|---------|-----|
|60cm |10cm/sec |10cm/sec |
| 50cm |9cm/sec| 9cm/sec |
| 30cm | 7cm/sec | 4cm/sec |
|20cm | 4cm/sec | 0cm/sec|

### Test Data
| Sonar S | $v_l$   |$v_r$|
|---------|---------|-----|
|40cm |8cm/sec |8cm/sec |
| 35cm |7.5cm/sec| 6cm/sec |
| 25cm | 6cm/sec | 2cm/sec |
"""

import numpy as np

#vl=a2S^2 + a1S +a0
x=np.array([0.60,0.50,0.30,0.20])
yd=np.array([10,9,7,4])
D=2

def createA(x, D):

    A=[]
    for i in x:
      l=[]
      for j in range(D+1):
        l.append(i**j)
      A.append(l)
    return np.asarray(A)

A=createA(x, D)
print(A)

def train_w(A, yd):
    #w = (2*np.random.rand(A.shape[1]) - 1)/2
    w=np.zeros(A.shape[1])
    eta = 0.06
    for j in range(100):
      for i in range(A.shape[0]):
        y = A.dot(w)
        e = yd[i]-y[i]
        #print(e)
        w = w + eta*e*A[i]
        if np.isclose(e,0,atol=0.001):
         break
    print(e)
    return w

w=np.array(train_w(A, yd))
print(w)

def predict_y(w, x):
    A=[]
    D=w.shape[0]
    for i in x:
      l=[]
      for j in range(D):
        l.append(i**j)
      A.append(l)
    A= np.asarray(A)
    y=A.dot(w)
    
    return y

y=np.array(predict_y(w, x))
print(y)

def compute_mse(y, yd):

    sum = 0
    for i in range(0,len(y)):
      y1=y[i]-yd[i]
      y1=y1*y1
      sum=sum+y1
    mse= sum/len(y)
    return mse

mse=np.array(compute_mse(y, yd))
print(mse)

def plotModel(x, y, yd):
    import matplotlib.pyplot as plt
    i = x.argsort()
    plt.figure()
    plt.plot(x[i],y[i],'g-o')
    plt.plot(x[i],yd[i],'r-o')
    plt.ylabel('f(x)')
    plt.xlabel('x')
    plt.legend(['estimated', 'true'])

plotModel(x, y, yd)

#Testing
x=np.array([0.40,0.35,0.25])
yd=np.array([8,7.5,6])

def createA(x, D):

    A=[]
    for i in x:
      l=[]
      for j in range(D+1):
        l.append(i**j)
      A.append(l)
    return np.asarray(A)
A=createA(x, D)
print(A)
def predict_y(w, x):
    A=[]
    D=w.shape[0]
    for i in x:
      l=[]
      for j in range(D):
        l.append(i**j)
      A.append(l)
    A= np.asarray(A)
    y=A.dot(w)
    
    return y
y=np.array(predict_y(w, x))
print(y)

def compute_mse(y, yd):

    sum = 0
    for i in range(0,len(y)):
      y1=y[i]-yd[i]
      y1=y1*y1
      sum=sum+y1
    mse= sum/len(y)
    return mse
  
mse=np.array(compute_mse(y, yd))
print(mse)
def plotModel(x, y, yd):
    import matplotlib.pyplot as plt
    i = x.argsort()
    plt.figure()
    plt.plot(x[i],y[i],'g-o')
    plt.plot(x[i],yd[i],'r-o')
    plt.ylabel('f(x)')
    plt.xlabel('x')
    plt.legend(['estimated', 'true'])
plotModel(x, y, yd)

