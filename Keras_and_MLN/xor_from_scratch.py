# -*- coding: utf-8 -*-
"""xor_from_scratch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BCa_2_8R5oAk2b4yNIwhYBAmSYy43yFI

## Implementing Back-propagation Algorithm with XOR data from scratch

### XOR data: <br>
**$ x_0 \ x_1 \ y$** <br>
$0 \ \ \  0 \ \ \  0$ <br>
$0 \ \ \  1 \ \ \  1$ <br>
$1 \ \ \  0 \ \ \  1$<br>
$1 \ \ \  1 \ \ \  0$<br>

--------

### Network Architecture

<img src="https://drive.google.com/uc?id=14Iw0rCAFHPsQjn93tFBwwnaoV0CuQc-3" title="" align="center" width="50%" height="50%"/>

### Importing Libraries
"""

import numpy as np
import matplotlib.pyplot as plt

"""### Data"""

# 0 is replaced by 0.1, 1 is replaced by 0.9
# 0.9 as bias 
X = np.array([[0.1, 0.1, 0.9], [0.1, 0.9, 0.9],[0.9, 0.1,0.9], [0.9, 0.9,0.9]])

Y = np.array([[0.1], [0.9],[0.9], [0.1]])

"""### Activation function and its derivative"""

def sigmoid (x):
    y = 1/(1 + np.exp(-x))
    return y
   
def sigmoid_derivative(x):
    return x * (1 - x)

"""### Initializing weights

<img src="https://drive.google.com/uc?id=14Iw0rCAFHPsQjn93tFBwwnaoV0CuQc-3" title="" align="center" width="50%" height="50%"/>
"""

ni = 3
nh = 4
no = 1

weights1   = (2*np.random.random((nh,ni)) - 1)*0.01/2
weights2   = (2*np.random.random((no,nh)) - 1)*0.01/2
eta = 1

"""### Training the Network"""

eta = 1
for epochs in range(5000):
    for s in range(X.shape[0]):
        ## forward propagation
        hidden = sigmoid(np.dot(weights1, X[s])).reshape(-1, 1)
        y = sigmoid(np.dot(weights2, hidden)).reshape(-1,1)
        
        ## backward propagation
        delta_weights2 = np.dot(((Y[s] - y) * sigmoid_derivative(y)),hidden.reshape(-1, 1).T)
        delta_weights1 = np.dot(((Y[s]-y) * sigmoid_derivative(y)*weights2.T * sigmoid_derivative(hidden)), X[s].reshape(1,3))

        ## update weights
        weights1 = weights1 + eta*delta_weights1
        weights2 = weights2 + eta*delta_weights2

"""### Testing the Network"""

error = 0

for s in range(X.shape[0]):
    hidden = sigmoid(np.dot(weights1, X[s])).reshape(-1, 1)
    y = sigmoid(np.dot(weights2, hidden)).reshape((-1,1))
    
    print('x:',X[s,:-1],' y:',y)
    error += (Y[s] - y).dot(Y[s] - y)

print('error:',error/4)

